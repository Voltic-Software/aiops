package config

import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

const (
	ConfigFileName = ".aiops.yaml"
	Version        = "0.1.0"
)

// ProjectConfig is the root configuration generated by `aiops init`.
type ProjectConfig struct {
	Version  string        `yaml:"version"`
	Project  Project       `yaml:"project"`
	Paths    Paths         `yaml:"paths"`
	Detected DetectedStack `yaml:"detected"`
}

// Project holds user-confirmed project metadata.
type Project struct {
	Name string `yaml:"name"`
}

// Paths holds the output locations for generated artifacts.
type Paths struct {
	Windsurf    string   `yaml:"windsurf,omitempty"`
	Memories    string   `yaml:"memories,omitempty"`
	Multiagency string   `yaml:"multiagency"`
	Targets     []string `yaml:"targets,omitempty"` // detected IDE targets: windsurf, cursor, continue, copilot
}

// DetectedStack holds the auto-detected technology stack.
type DetectedStack struct {
	Languages  []Language  `yaml:"languages"`
	Frameworks []Framework `yaml:"frameworks"`
	Build      BuildInfo   `yaml:"build"`
	Patterns   []string    `yaml:"patterns"`
	GoModule   string      `yaml:"go_module,omitempty"`
}

// Language represents a detected programming language.
type Language struct {
	Name       string `yaml:"name"`
	Confidence string `yaml:"confidence"` // high, medium, low
	EntryDir   string `yaml:"entry_dir,omitempty"`
}

// Framework represents a detected framework or library.
type Framework struct {
	Name       string `yaml:"name"`
	Language   string `yaml:"language"`
	Confidence string `yaml:"confidence"`
	Dir        string `yaml:"dir,omitempty"`
}

// BuildInfo holds detected build and generation commands.
type BuildInfo struct {
	Commands           []string `yaml:"commands"`
	GenerateCommands   []string `yaml:"generate_commands,omitempty"`
	TestCommands       []string `yaml:"test_commands,omitempty"`
	GeneratedFileMarks []string `yaml:"generated_file_markers,omitempty"`
}

// DefaultPaths returns the default output paths for a project.
func DefaultPaths() Paths {
	return Paths{
		Windsurf:    ".windsurf",
		Memories:    "", // resolved at runtime from $HOME
		Multiagency: "multiagency",
	}
}

// Load reads a ProjectConfig from the given directory.
func Load(dir string) (*ProjectConfig, error) {
	path := filepath.Join(dir, ConfigFileName)
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("no %s found in %s: %w", ConfigFileName, dir, err)
	}
	var cfg ProjectConfig
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		return nil, fmt.Errorf("invalid %s: %w", ConfigFileName, err)
	}
	return &cfg, nil
}

// Save writes the ProjectConfig to the given directory.
func Save(dir string, cfg *ProjectConfig) error {
	path := filepath.Join(dir, ConfigFileName)
	data, err := yaml.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}
	header := "# Generated by aiops init â€” do not edit manually unless you know what you're doing.\n# Run `aiops status` to check for updates.\n\n"
	return os.WriteFile(path, []byte(header+string(data)), 0644)
}

// Exists checks if a config file exists in the given directory.
func Exists(dir string) bool {
	path := filepath.Join(dir, ConfigFileName)
	_, err := os.Stat(path)
	return err == nil
}
