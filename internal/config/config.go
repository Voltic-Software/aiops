package config

import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

const ConfigFileName = ".aiops.yaml"

// Version is set at build time via ldflags.
var Version = "dev"

// ProjectConfig is the root configuration generated by `aiops init`.
type ProjectConfig struct {
	Version  string        `yaml:"version"`
	Project  Project       `yaml:"project"`
	Paths    Paths         `yaml:"paths"`
	Detected DetectedStack `yaml:"detected"`
}

// Maturity levels for project lifecycle.
const (
	MaturityBootstrap = "bootstrap" // New/empty repo, architecture phase
	MaturityActive    = "active"    // Building, single-agent default
	MaturityMature    = "mature"    // Established, strict gating
)

// Project holds user-confirmed project metadata.
type Project struct {
	Name     string `yaml:"name"`
	Maturity string `yaml:"maturity"` // bootstrap, active, mature
}

// Paths holds the output locations for generated artifacts.
type Paths struct {
	Windsurf    string   `yaml:"windsurf,omitempty"`
	Multiagency string   `yaml:"multiagency"`
	Targets     []string `yaml:"targets,omitempty"` // detected IDE targets: windsurf, cursor, continue, copilot
}

// DetectedStack holds the auto-detected technology stack.
type DetectedStack struct {
	Languages  []Language      `yaml:"languages"`
	Frameworks []Framework     `yaml:"frameworks"`
	Build      BuildInfo       `yaml:"build"`
	Patterns   []string        `yaml:"patterns"`
	GoModule   string          `yaml:"go_module,omitempty"`
	MCPServers []MCPServer     `yaml:"mcp_servers,omitempty"`
	Skills     []DetectedSkill `yaml:"skills,omitempty"`
	Specs      []DetectedSpec  `yaml:"specs,omitempty"`
}

// MCPServer represents a detected MCP server configuration.
type MCPServer struct {
	Name    string `yaml:"name"`              // Server name (key from mcpServers)
	Command string `yaml:"command,omitempty"` // e.g., "npx", "uvx", "node"
	Source  string `yaml:"source"`            // Where it was found: "windsurf", "cursor", "vscode", "project"
}

// DetectedSkill represents a skill found in the project's skills directory.
type DetectedSkill struct {
	Name        string `yaml:"name"`
	Description string `yaml:"description,omitempty"`
	Trigger     string `yaml:"trigger,omitempty"`
}

// DetectedSpec represents a multiagency spec YAML found in the project.
type DetectedSpec struct {
	File        string `yaml:"file"`                  // e.g., "design.yaml"
	Name        string `yaml:"name"`                  // from spec's name: field
	Description string `yaml:"description,omitempty"` // brief purpose
	Agents      string `yaml:"agents,omitempty"`      // pipeline summary, e.g., "Architect → Critic → Fixer"
}

// Language represents a detected programming language.
type Language struct {
	Name       string `yaml:"name"`
	Confidence string `yaml:"confidence"` // high, medium, low
	EntryDir   string `yaml:"entry_dir,omitempty"`
}

// Framework represents a detected framework or library.
type Framework struct {
	Name       string `yaml:"name"`
	Language   string `yaml:"language"`
	Confidence string `yaml:"confidence"`
	Dir        string `yaml:"dir,omitempty"`
}

// BuildInfo holds detected build and generation commands.
type BuildInfo struct {
	Commands           []string `yaml:"commands"`
	GenerateCommands   []string `yaml:"generate_commands,omitempty"`
	TestCommands       []string `yaml:"test_commands,omitempty"`
	GeneratedFileMarks []string `yaml:"generated_file_markers,omitempty"`
}

// DefaultPaths returns the default output paths for a project.
func DefaultPaths() Paths {
	return Paths{
		Windsurf:    ".windsurf",
		Multiagency: "multiagency",
	}
}

// Load reads a ProjectConfig from the given directory.
func Load(dir string) (*ProjectConfig, error) {
	path := filepath.Join(dir, ConfigFileName)
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("no %s found in %s: %w", ConfigFileName, dir, err)
	}
	var cfg ProjectConfig
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		return nil, fmt.Errorf("invalid %s: %w", ConfigFileName, err)
	}
	return &cfg, nil
}

// Save writes the ProjectConfig to the given directory.
func Save(dir string, cfg *ProjectConfig) error {
	path := filepath.Join(dir, ConfigFileName)
	data, err := yaml.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}
	header := "# Generated by aiops init — do not edit manually unless you know what you're doing.\n# Run `aiops status` to check for updates.\n\n"
	return os.WriteFile(path, []byte(header+string(data)), 0644)
}

// Exists checks if a config file exists in the given directory.
func Exists(dir string) bool {
	path := filepath.Join(dir, ConfigFileName)
	_, err := os.Stat(path)
	return err == nil
}
