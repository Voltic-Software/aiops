---
description: Default execution mode for single-agent tasks - pragmatic, codebase-grounded engineering
---

# Default Execution Mode — Reference Manual

This is the expanded reference for the rules defined in the repo rules file. The repo rules are always active; this document provides detailed examples, tables, and procedures.
{{- if .HasMCP}}

## MCP Tools Reference

Ground your understanding before making changes. Use available MCP tools to verify assumptions against the actual codebase before writing code.

| Tool | When to Use |
|---|---|
{{- range .MCPServers}}
| Tools from `{{.Name}}` server | Domain-specific queries, codebase search, schema inspection |
{{- end}}

When an MCP server is available for the task domain, prefer using its tools over manual file exploration.
{{- else}}

## MCP Tools Reference

Ground your understanding before making changes. Use available tools (search, file reading, grep) to verify assumptions against the actual codebase before writing code.
{{- end}}

## Tier Routing — Examples

### Tier 1 — Default (Just Do It)

- "Add a new field to an existing model" → Direct implementation
- "Fix this null pointer bug" → Investigate, fix, verify
- "Update this endpoint response" → Targeted change following existing patterns

### Tier 2 — Focused Expert (Analyze First, Then Implement)
{{- if .HasSkills}}

| Skill | Trigger | What It Provides |
|---|---|---|
{{- range .Skills}}
| `@{{.Name}}` | {{if .Trigger}}{{.Trigger}}{{else}}{{.Description}}{{end}} | Structured procedure + reference materials |
{{- end}}

Each skill includes supporting reference files that are read automatically when invoked.
{{- end}}

**Focused Expert Behavior:**

1. {{if .HasSkills}}Auto-invoke the relevant skill based on task description{{else}}Identify the relevant domain/area{{end}}
2. {{if .HasSkills}}Skill provides structured procedure + reference materials{{else}}Gather context from the codebase{{end}}
3. Use MCP tools to gather domain context before writing code
4. Analyze the impact and constraints
5. Then implement with full understanding
{{- if .HasSkills}}

**Examples:**
{{- range .Skills}}
- Task involving {{.Name}} → `@{{.Name}}` auto-invokes
{{- end}}
{{- end}}

### Tier 3 — Multiagency (Escalate)
{{- if .HasSpecs}}

**Available workflows:**

| Workflow | Purpose | Pipeline |
|---|---|---|
{{- range .Specs}}
| `{{.File}}` | {{.Name}} | {{.Agents}} |
{{- end}}
{{- end}}

**Escalation Budget**: Max {{if .IsBootstrap}}4{{else if .IsMature}}1{{else}}2{{end}} escalations per session. After that, default to Tier 1 unless genuinely dangerous. Each escalation must include a concrete reason — "this is complex" is not sufficient.

**Escalation format:**

```
This task would benefit from a multi-agent workflow because [concrete reason].
Recommended: `/multiagency [workflow] [task description]`
```

## Session Coordination — Detailed Reference

See `/orchestrator` for full command reference. Quick summary:

| Command                  | Purpose                                            |
| ------------------------ | -------------------------------------------------- |
| `/orchestrator sync`     | Register session, check for conflicts, claim locks |
| `/orchestrator lock`     | Claim advisory ownership of a codebase area        |
| `/orchestrator unlock`   | Release a lock                                     |
| `/orchestrator status`   | View current state                                 |
| `/orchestrator complete` | End session, release locks, record outcome         |
| `/orchestrator note`     | Add a cross-cutting note for all sessions          |

**Build Failure Decision Tree:**

```
Build failed → Check area → Active lock?
  ├─ YES, I own it → Fix it
  ├─ YES, lock allows external fixes → Fix it
  ├─ YES, lock denies external fixes → REPORT ONLY (do not fix)
  └─ NO lock → Safe to fix
```
{{- if .HasSkills}}

## Knowledge Freshness

Agent knowledge is stored in explicit artifacts, not agent memory:

- **Skills directory** — Domain-specific procedures and reference files
- **Repo rules** — Core principles and routing logic
- **Decisions directory** — Architectural decisions (if present)

Run `/multiagency evolution_audit.yaml` to detect knowledge drift and get update proposals.
{{- end}}

## Project-Specific Guidelines
{{if .HasGo}}
### Backend (Go)
{{if .HasEventsrc}}
- Follow eventsrc patterns for domain changes
- Use DSL for read models, commands, events{{end}}
{{- range .Build.GenerateCommands}}
- Run `{{.}}` after relevant changes{{end}}
{{- range .Build.Commands}}
{{- if eq . "go build ./..."}}
- Check generated files compile: `go build ./...`{{end}}{{end}}
{{end}}
{{- if .HasTS}}
### Frontend (TypeScript)
{{if .HasNextJS}}
- Follow Next.js page/component patterns{{end}}
{{- if .HasReact}}
- Use existing shared components and design system{{end}}
- Maintain TypeScript strict typing
{{- range .Build.Commands}}
{{- if eq . "npx tsc --noEmit"}}
- Type check: `npx tsc --noEmit`{{end}}{{end}}
{{end}}
{{- if .HasPython}}
### Python

- Follow existing patterns and type hints
- Use project linters and formatters
- Run tests after changes
{{end}}
{{- if .HasRust}}
### Rust

- Follow ownership and borrowing patterns
- Run `cargo clippy` after changes
- Maintain type safety
{{end}}
